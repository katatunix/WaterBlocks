Trong tuyển tập các đề thi tin học của "Cuộc thi Olympic truyền thống 30 tháng 4" những năm 1999-2000 có bài này làm mình nhớ mãi:

Cho một địa hình có dạng chữ nhật kích thước MxN. Mỗi vị trí (i, j) có độ cao là một số tự nhiên h[i][j] (i=1..M, j=1..N). Sau một trận mưa to, hãy tính tổng thể tích nước đọng lại trên địa hình.

Đây rõ ràng là một bài áp dụng triệt để thuật toán loang ( loang dầu ăn hoặc nước đều được :D )

Nhận xét:

Một ô (i, j, k) được gọi là ô trống nếu độ cao của (i, j) thấp hơn k, tức là h[i][j] < k.

Nếu một ô trống (i, j, k) đọng nước thì tất cả các ô trống (i, j, k2) với k2 < k cũng sẽ đọng nước.

Nếu một ô trống (i, j, k) KHÔNG đọng nước thì tất cả các ô trống (i, j, k2) với k2 > k cũng sẽ KHÔNG đọng nước.

Xét một ô trống (i, j, k):
	Nếu tồn tại một đường đi bắt đầu từ (i, j, k) qua các ô trống kề cạnh ở cùng độ cao k, mà đi tới một ô nào đó ở ngoài biên; thì ô (i, j, k) sẽ KHÔNG đọng nước.
	
	Nếu không tồn tại một đường đi như vậy thì ô (i, j, k) sẽ đọng nước.
	
	Việc đi tìm một đường đi như vậy gọi là "loang" bắt đầu từ (i, j, k).
	
	Loang gọi là thành công nếu KHÔNG tồn tại đường đi như vậy.
	
	Nếu loang thành công, thì ko chỉ ô (i, j, k) mà tất cả các ô loang tới cũng sẽ đọng nước.

Ta có thuật toán sau đây:

Đặt mảng water[2..M-1][2..N-1] dùng để chứa thể tích nước sẽ đọng lại ở mỗi vị trí (2..M-1, 2..N-1). Hiển nhiên ô ngoài biên sẽ không thể đọng nước nên ta chỉ xét các vị trí (2..M-1, 2..N-1).

Khởi tạo water[i][j] = 0 với mọi i=2..M-1, j=2..N-1

Duyệt qua lần lượt các vị trí (i, j): i=2..M-1, j=2..N-1
	Đặt k = h[i][j] + 1, giờ ta kiểm tra xem ô (i, j, k) có thể đọng nước được ko bằng cách loang từ (i, j, k).
	
	Nếu loang thành công thì tất cả các ô được loang (i2, j2) bao gồm (i, j) sẽ được cập nhật: water[i2][j2] = k - h[i2][j2]. Tăng k=k+1 và lặp lại loang.
	
	Nếu loang thất bại thì dừng lặp và chuyển qua vị trí (i, j) kế tiếp. Chú ý rằng lúc này ta có thể chắc chắn các ô (i2, j2) ở lần loang kề trước (thành công) sẽ KHÔNG thể chứa thêm nước được nữa (*). Do đó khi chuyển sang vị trí (i, j) kế tiếp ta có thể kiểm tra water[i][j] phải bằng zero thì mới xem xét.
	
Kết quả cuối cùng sẽ là tổng các water[i][j].
	
Chứng minh (*):
	
Giả sử lần loang thành công cuối cùng là ở độ cao k, và lần loang thất bại là ở độ cao k+1. Do từ (i, j, k) ta loang được tới (i2, j2, k) nên từ (i, j, k+1) ta cũng loang được tới (i2, j2, k+1). Suy ra tồn tại một đường đi từ (i2, j2, k+1) tới (i, j, k+1) và tiếp tục đi ra ngoài biên (vì lần loang cuối thất bại). Do đó ô (i2, j2, k+1) KHÔNG thể đọng nước.

Code C:

[code language="cpp"]
#include <stdio.h>
#include <conio.h>
#include <cassert>

#define FI "WaterBlocks.inp"

#define _MAX 100
#define MAX (_MAX + 1)

int M, N;
int h[MAX][MAX];

int water[MAX][MAX];
bool markLoang[MAX][MAX];

int queueRow[MAX * MAX]; // for loang
int queueCol[MAX * MAX]; // for loang

int u[4] = { 0, 0, -1, 1 }; // direction X
int v[4] = { 1, -1, 0, 0 }; // direction Y

void readinput()
{
	FILE* f = fopen(FI, "rt");
	fscanf(f, "%d %d", &M, &N);
	for (int i = 1; i <= M; i++)
	{
		for (int j = 1; j <= N; j++)
		{
			fscanf(f, "%d", &(h[i][j]));
		}
	}
	fclose(f);
}

bool isBorder(int i, int j)
{
	return i == 1 || i == M || j == 1 || j == N;
}

bool isInside(int i, int j)
{
	return i >= 1 && i <= M && j >= 1 && j <= N;
}

// return true if the square (row, col, height) can store water
bool loang(int row, int col, int height)
{
	for (int i = 2; i < M; i++) for (int j = 2; j < N; j++)
	{
		markLoang[i][j] = false;
	}
	markLoang[row][col] = true;

	int first, last;
	first = last = 1;
	queueRow[1] = row;
	queueCol[1] = col;
	while (first <= last)
	{
		int r = queueRow[first];
		int c = queueCol[first];
		first++;
		for (int dir = 0; dir < 4; dir++)
		{
			int rNext = r + u[dir];
			int cNext = c + v[dir];
			
			if ( !isInside(rNext, cNext) ) continue;

			if (markLoang[rNext][cNext]) continue;

			if (h[rNext][cNext] >= height) continue; // the square must be empty

			if (isBorder(rNext, cNext)) return false; // we can travel to the border, so return false

			//if (water[rNext][cNext] > 0) return false;

			markLoang[rNext][cNext] = true;
			last++;
			queueRow[last] = rNext;
			queueCol[last] = cNext;
		}
	}

	return true;
}

void updateWater(int height)
{
	for (int i = 2; i < M; i++) for (int j = 2; j < N; j++)
	{
		if (markLoang[i][j])
		{
			water[i][j] = height - h[i][j];
			assert(water[i][j] > 0);
		}
	}
}

void solve()
{
	for (int i = 2; i < M; i++) for (int j = 2; j < N; j++)
	{
		water[i][j] = 0;
	}

	//--------------------------------------------------------------
	for (int i = 2; i < M; i++) for (int j = 2; j < N; j++)
	{
		if (water[i][j] == 0) // with water[i][j] > 0 we make sure that it no longer stores water
		{
			int k = h[i][j] + 1;
			while (loang(i, j, k))
			{
				updateWater(k);
				k++;
			}
		}
	}
	//--------------------------------------------------------------
}

void writeoutput()
{
	int sum = 0;
	for (int i = 2; i < M; i++) for (int j = 2; j < N; j++)
	{
		sum += water[i][j];
	}

	printf("%d", sum);
	_getch();
}

void main()
{
	readinput();
	solve();
	writeoutput();
}
[/code]







